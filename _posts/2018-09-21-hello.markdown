---
layout: post
title:  "hello"
date:   2018-09-21 13:04:09 +0800
categories: jekyll update
---
注：本文主要基于洛谷P3367（[传送门](https://www.luogu.org/problemnew/show/P3367 "传送门")）且本文中给的代码会TLE三个点（[评测记录](https://www.luogu.org/record/show?rid=10839850)）；具体优化请见后续文章。

**并查集**是一种极为常用的方法，它的用处不仅局限于处理集合相关问题，同时还可以优化其他的算法（最显然的例子：最小生成树的**Kruskal算法**）。

首先，在介绍**并查集**之前，我们假设您已经了解了一下内容：
- 递归相关
- **树**的最基本内容
- **一棵树可以看做一个集合**，所以检查两个节点所在树的根节点是否相同就可以判断他们是否在同一棵树中

下面让我们进入正题。

对于题目的意思，我们可以很轻易的找出一个
```math
O(n^2)
```
的算法：
设置一个数组p，p[i]表示第i个数处于哪个集合中。对于合并操作，以O（n）的时间复杂度枚举每一个元素，判断是否在同一集合中；对于查询操作，可以以O（1）的时间完成。
那么总的时间复杂度是
```math
O(NM)
```

显然，这对于某些数据比较大的题目来说会超时。

那么，让我们观察一下上面的算法——它的主要时间耗在合并集合上。那么,我们能不能找到一个方法优化合并集合上呢？

让我们回顾一下前面的内容：
> **一棵树可以看做一个集合**，所以检查两个节点所在树的根节点是否相同就可以判断他们是否在同一棵树中。

那么，我们很自然的可以想到：在合并集合的时候合并这两个集合的根节点就行了（或者说，合并这两个代表元素）。
也就是说，我们可以**维护一个森林，使得在相同集合中的元素在同一棵树中；同时，对于每一棵树，用它的根节点来代表这棵树所在的集合。**

那么，问题是，怎么维护这样一片森林呢？

我们先假设，最开始的每个节点都单独是一棵树，根节点是自己（如下图）。
![image](http://wuxinyuan.edisoncloud.ga/wp-content/uploads/2018/09/a.png)
然后读入了以下几步操作：
- 合并1，2
- 合并3，4
- 合并2，3

那么处理如下（仅展示第一个操作，其余同理）：
- 在第一棵树中找到它的根节点1，同理在第二棵树中找到它的根节点2；（**称为找根节点，我个人习惯用一个递归函数getf()**）
- 把节点2（即第二棵树的根节点）的fa数组值赋值为1（即第一棵树的根节点），那么第一二棵树就合并成了一个新的以第一棵树为根节点的树（**称为合并操作，我一般不用函数，但你非要写一个merge可以**）。

再假设数据开始提问：
- 查询1，4是否在同一集合中

由上可知，**两个元素在同一个集合中和两个元素所在树的根节点相同是可以相互推出的。**
那么处理如下：
- 查询1，4两个元素所在的树根节点并判断是否相同即可。

下面是getf()函数的未优化代码：

```cpp
int getf(int x)
{
    if (fa[x]==x)
        return x;
    else
        return getf(fa[x]);
}
```

说完了算法，下面让我们来分析一下效率：
- 合并操作（n次总的，k为元素数）：
```math
O(nlogk)
```
- 查询操作（m次总的）：

```math
O(mlogk)
```
所以**总的复杂度**是：

```math
O(mlogk+nlogk)
``` 

下面是完整代码：


```cpp
#include <stdio.h>
#include <string.h>

int fa[10001];

int getf(int x)
{
    if (fa[x]==x)
        return x;
    else
        return getf(fa[x]);
}

void putf(int x,int y)
{
    int fx=getf(x);
    int fy=getf(y);
    fa[fx]=fy;
}

int main()
{
    int n,m,p;
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
        fa[i]=i;
    int z,mi,mj;
    for (int i=1;i<=m;i++)
    {
    	scanf("%d%d%d",&z,&mi,&mj);
    	if (z==1)
    	{
    		putf(mi,mj);
        }
        if (z==2)
        {
            if (getf(mi)==getf(mj))
                printf("Y\n");
            else printf("N\n");
        }
    }
    return 0;
}
```
